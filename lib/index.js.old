'use strict'

/******************************* Dependencies ********************************/

var _    = require('lodash')
var fs   = require('fs')
var pt   = require('path')
var glob = require('glob')
var yaml = require('js-yaml')

/******************************** Constructor ********************************/

/**
 * Statil constructor. Takes a hash of options for lodash's template parser,
 * adds some defaults, and assigns them to self. Sets a few other utility
 * fields.
 * @param Hash
 */
function Statil(options) {
  // Self-correct when called without 'new'.
  if (!(this instanceof Statil)) return new Statil(options)

  // Make sure options is a writable object.
  if (!_.isObject(options)) options = Object.create(null)

  /**
   * Assign default imports to self.
   */
  this.imports = methods.imports.call(this)

  /**
   * Merge provided options into self.
   */
  _.merge(this, options)

  /**
   * Map of parsed template paths to compiled templates.
   * @type Hash{Function}
   */
  this.templates = Object.create(null)

  /**
   * Map of metadata directory paths to parsed metadata objects.
   * @type Hash{Hash}
   */
  this.metas = Object.create(null)
}

/****************************** Public Methods *******************************/

/*-------------------------------- Rendering --------------------------------*/

/**
 * Renders all templates, passing the given data. Skips templates matching the
 * 'ignored' expression in their directory's metadata. Returns a map of paths
 * to rendered strings.
 * @param   Hash (optional)
 * @returns Hash{String}
 */
Statil.prototype.renderAll = function(data) {
  var buffer = Object.create(null)

  _.each(this.templates, function(t, path) {
    if (methods.isIgnored.call(this, path)) return
    _.assign(buffer, methods.renderFile.call(this, path, data))
  }, this)

  return buffer
}

/*--------------------------------- Pathing ---------------------------------*/

/**
 * Registers the given file under the given path, which is assumed to be a
 * file path. If srcDir is passed, this prefix is stripped from the path.
 *
 * If the file has a .yaml or .json extension, it's parsed as a YAML file
 * (superset of JSON) and registered as a meta under its directory's path.
 * Otherwise it's compiled with lodash and registered as a template under its
 * own path without the extension. We pass statil's clone to lodash's template
 * parser as a config hash.
 *
 * @param String source
 * @param String path
 * @param String srcDir (optional)
 */
Statil.prototype.register = function(source, path, srcDir) {
  // Validate the arguments.
  validateString(source)
  validateTruthyString(path)
  if (srcDir != null) validateTruthyString(srcDir)

  // If srcDir is given, rebase the path.
  if (srcDir) {
    path = pt.relative(srcDir, path)
  }

  /**
   * If this is a yaml or json file, register as a meta.
   */
  if (pt.extname(path) === '.yaml' || pt.extname(path) === '.json') {
    // Strip the file name.
    path = pt.dirname(path)
    // Mandate no more than one meta per path.
    if (this.metas[path]) {
      throw new Error('duplicate meta for path: ' + path)
    }
    // Parse and register the meta.
    this.metas[path] = yaml.safeLoad(source)
  }
  /**
   * Otherwise register as a template.
   */
  else {
    // Strip the file extension.
    path = pt.join(pt.dirname(path), pt.parse(path).name)
    // Compile and register the template.
    this.templates[path] = _.template(source, clone(this))
  }
}

/**
 * Scans the directory at the given path, relative to the cwd of the current
 * process, and registers each file.
 */
Statil.prototype.scanDirectory = function(srcDir) {
  // Validate the input.
  validateTruthyString(srcDir)

  // Read the paths of the files in the given directory.
  var paths = glob.sync(pt.join(srcDir, '**/*'), {nodir: true, nonull: true})

  // Read and register each file.
  paths.forEach(function(path) {
    this.register(fs.readFileSync(path, 'utf-8'), path, srcDir)
  }, this)
}

/**
 * Takes a path to a file and returns the metadata associated with its
 * directory. Also accepts a path to a directory with a trailing slash.
 *
 * These are equivalent:
 *   this.meta('partials/my-template')
 *   this.meta('partials/')
 *
 * This is different:
 *   this.meta('partials')
 *
 * @param   String
 * @returns *|undefined
 */
Statil.prototype.meta = function(path) {
  // Validate the input.
  validateString(path)

  var dirname
  // Allow to indicate a directory path with a trailing slash.
  if (path.slice(-1) === '/') dirname = path.slice(0, -1)
  // Otherwise strip the file name.
  else dirname = pt.dirname(path)

  return this.metas[dirname]
}

/**
 * Takes a path to a file and returns its legend from the metadata associated
 * with its directory, if available. The legend is identified by having the
 * same 'name' property as the file's name.
 * @param   String
 * @returns Legend|undefined
 */
Statil.prototype.legend = function(path) {
  // Validate the input.
  validateString(path)
  // Return the legend or undefined.
  var meta = this.meta(path)
  if (meta) return _.find(meta.files, {name: pt.basename(path)})
}

/****************************** Private Methods ******************************/

/**
 * Private methods are stored on a conditionally exported object and accessed
 * on it dynamically. This allows us to intercept and mock them in unit tests.
 * @type Hash
 */
var methods = Object.create(null)
if (process.env.STATIL_ENV === 'testing') Statil.methods = methods

/*-------------------------------- Rendering --------------------------------*/

/**
 * Renders the template at the given path, passing the given locals. The path
 * must be a non-empty string. The locals are optional.
 * @param   String path
 * @param   Hash   data (optional)
 * @returns String
 */
methods.renderOneTemplate = function(path, data) {
  // Validate the path and resolve it to a template function.
  var template = methods.resolve.call(this, path)

  // Make sure data is a writable object.
  if (!_.isObject(data)) data = Object.create(null)

  // Provide default locals to the data.
  methods.locals.call(this, path, data)

  // Assign the path once. The path should never be reassigned during a
  // recursive render chain.
  if (!data.$path) data.$path = path

  // Render the result.
  return template.call(this, data)
}

/**
 * Hierarchically renders all templates from the current path, through its
 * ancestors, up to the root 'index' template. Reuses the same mutable locals
 * object between render passes. The result of each pass is assigned to locals
 * as '$content' for transclusion in the next ancestor template.
 *
 * The path must be a non-empty string. The locals are optional.
 *
 * @param   String path
 * @param   Hash   data (optional)
 * @returns String
 */
methods.renderTemplate = function(path, data) {
  // Validate the path.
  validateTruthyString(path)

  // Make sure data is a writable object.
  if (!_.isObject(data)) data = Object.create(null)

  // Get the paths at which to render.
  var compounded = split(path)

  // Render the result hierarchically.
  _.eachRight(compounded, function(compoundedPath) {
    data.$content = methods.renderOneTemplate.call(this, compoundedPath, data)
  }, this)

  return data.$content
}

/**
 * Same as #renderTemplate, but before rendering, checks the template's legend
 * (if any) and echoes it (if the echo property is defined). Renders the
 * template once for each echoed legend, passing a clone of the given locals
 * enhanced with the legend details. Returns a hash of results, where keys are
 * virtual paths.
 * @param   String
 * @returns Hash
 */
methods.renderFile = function(path, data) {
  var buffer = Object.create(null)

  var legend = this.legend(path)
  // If no legend is available, render normally.
  if (!legend) {
    buffer[path] = methods.renderTemplate.call(this, path, clone(data))
    return buffer
  }

  // Echo the legend and render each.
  var legends = echoLegend(this.meta(path), legend)
  _.each(legends, function(legend) {
    // Form a new virtual path.
    var echoPath = pt.join(pt.dirname(path), legend.name)
    var locals = _.assign(clone(data), legend)
    locals.$path = echoPath
    // Render and assign the result under this virtual path.
    buffer[echoPath] = methods.renderTemplate.call(this, path, locals)
  }, this)

  return buffer
}

/*---------------------------------- Setup ----------------------------------*/

/**
 * Generates a hash of default imports for lodash's template parser.
 * @returns Hash
 */
methods.imports = function() {
  /**
   * Hash of imports for templates.
   * @type Hash
   */
  var imports = Object.create(null)

  /**
   * Self-reference for closuring.
   * @type Statil
   */
  var self = this

  /**
   * Renders the template with the given path and the given data and returns
   * the result. The data is cloned before it's passed to the renderer.
   * @param String path
   * @param Hash   data
   */
  imports.$include = function $include(path, data) {
    // Clone the data object and pass arguments to #renderOneTemplate.
    data = clone(data)
    return methods.renderOneTemplate.call(self, path, data)
  }

  /**
   * Prepends or assigns the given string to the page's title stored as
   * 'data.$title'. This mutates the title, prepending new parts, if called
   * several times over the data's lifecycle. A non-string or empty title is
   * ignored.
   * @param String title
   * @param Hash   data
   */
  imports.$entitle = function $entitle(title, data) {
    if (!_.isObject(data)) return
    if (typeof title !== 'string' || !title) return

    if (typeof data.$title !== 'string' || !data.$title) {
      data.$title = title
    } else {
      data.$title = title + ' | ' + data.$title
    }
  }

  /**
   * Takes a path and a data object; returns 'active' if the path is included
   * into the URL/template path specified in the data (if any), and an empty
   * string otherwise.
   * @param   String path
   * @param   Hash   data
   * @returns String
   */
  imports.$active = function $active(path, data) {
    if (!_.isObject(data)) return ''
    if (typeof path !== 'string') return ''
    if (typeof data.$path !== 'string') return ''

    var relative = pt.relative(data.$path, path)
    if (relative === '..' || relative[0] !== '.') return 'active'
    return ''
  }

  /**
   * Version of $active that returns the attribute 'class="active"' if
   * matched.
   * @param   String path
   * @param   Hash   data
   * @returns String
   */
  imports.$act = function $act(path, data) {
    if (imports.$active(path, data)) return 'class="active"'
    return ''
  }

  return imports
}

/**
 * Takes a path to a template file and a data object. Writes contextual locals
 * into that object.
 * @param String
 * @param Hash
 */
methods.locals = function(path, data) {
  // Validate the input.
  validateString(path)
  validateHash(data)

  // Make sure '$content' is always defined and is a string.
  if (typeof data.$content !== 'string') data.$content = ''

  // Make sure '$title' is always defined and is a string.
  if (typeof data.$title !== 'string') data.$title = ''

  // Reference the data itself as '$'.
  data.$ = data

  // Include the metadata associated with the current directory, if any.
  var meta = this.meta(path)
  if (meta) data.$meta = meta

  /**
   * Include the file's legend from the directory's metadata, if available.
   * Note: these locals are intentionally allowed to "bleed through" to
   * ancestor templates during a Statil#renderTemplate pass.
   */
  var legend = this.legend(path)
  if (legend) _.assign(data, legend)
}

/**
 * Resolves the given compounded path against own template cache. The last
 * name in the path is assumed to be a template name. If it's not 'index',
 * then a template must be found by that name, otherwise an error is thrown.
 * If the last name is 'index', then we're going to be lenient: if a template
 * at this path is not found, we're using a minimal pass-through substitute
 * that simply transcludes the content.
 *
 * Returns the found or substituted template.
 *
 * @param   String
 * @returns Function
 */
methods.resolve = function(path) {
  // Validate the input.
  validateTruthyString(path)

  // Get the base name.
  var name = pt.basename(path)

  // If it's not index, mandate some kind of template.
  if (name !== 'index' && !this.templates[path]) {
    throw new Error('template not found at path: ' + path)
  }

  // Otherwise try to return a template or use a substitute.
  return this.templates[path] || transclude
}

/**
 * Checks if the name of the template at the given path matches the 'ignore'
 * expression in that directory's metadata, if any.
 * @param   String
 * @returns Boolean
 */
methods.isIgnored = function(path) {
  var meta = this.meta(path)
  if (!meta || !meta.ignore) return false
  validateTruthyString(meta.ignore)
  return !!pt.basename(path).match(meta.ignore)
}

/****************************** Private Statics ******************************/

/**
 * Clones the given value into a pure hash table.
 * @returns Hash
 */
function clone(hash) {
  return _.assign(Object.create(null), _.clone(hash))
}

/**
 * Splits the given path into an array of hierarchical paths. Appends 'index'
 * to each directory path.
 * @param String path
 * @returns Array[String]
 */
function split(path) {
  validateTruthyString(path)

  var parts = path.split(pt.sep)
  var compounded = []

  // Compound each path.
  parts.forEach(function(part, index) {
    // If this is a directory, disallow the name 'index'.
    if (index !== parts.length - 1 && part === 'index') {
      throw new Error("name 'index' is not allowed for directories")
    }

    // Add the compounded part.
    compounded.push(pt.join.apply(pt, parts.slice(0, index + 1)))
  })

  // Add the 'index' template name to each directory's path.
  compounded.slice(0, compounded.length - 1).forEach(function(p, index) {
    compounded[index] = pt.join(compounded[index], 'index')
  })

  // Add the implicit base 'index' template.
  compounded.unshift('index')

  // Remove the duplicates that occur when the path references an index template.
  compounded = _.uniq(compounded)

  return compounded
}

/**
 * Base transcluder template used as a substitute for a missing 'index' file.
 * @type Function
 */
var transclude = _.template('<%= $content %>')

/**
 * Resolves a legend relatively to a meta by echoing it zero or more times,
 * according to its echo property.
 * @param   Hash
 * @param   Legend
 * @returns Legend[]
 */
function echoLegend(meta, legend) {
  // Validate the input.
  validateHash(meta)
  validateLegend(legend)

  // Resolve the echo relative to the meta.
  var echo = legend.echo
  // In absence of an echo property, echo the legend as itself.
  if (!echo) return [legend]
  // If the echo is a string, assume it to be a key for a meta property.
  if (typeof echo === 'string') echo = meta[echo]
  // Otherwise mandate it to be an array.
  if (!_.isArray(echo)) {
    throw new TypeError('expected echo to resolve to an array, got: ' + echo)
  }

  // Map the resolved array to an array of extended legends, assigning their
  // properties to a clone of the original legend.
  return _.reduce(echo, function(buffer, subLegend) {
    return buffer.concat(echoLegend(meta, _.assign(clone(legend), subLegend)))
  }, [])
}

/*------------------------------- Validators --------------------------------*/

/**
 * Validates a hash table.
 * @param ?Hash
 */
function validateHash(value) {
  if (!_.isObject(value) || _.isArray(value)) {
    throw new TypeError('expected a hash table, got: ' + value)
  }
}

/**
 * Validates a file legend.
 * @param ?Legend
 */
function validateLegend(legend) {
  validateHash(legend)
  if (typeof legend.name !== 'string' || !legend.name) {
    throw new TypeError('expected a legend to contain a non-empty name, got: ' + legend.name)
  }
}

/**
 * Validates a string.
 * @param ?String
 */
function validateString(value) {
  if (typeof value !== 'string') {
    throw new TypeError('expected a string, got: ' + value)
  }
}

/**
 * Validates a non-empty string.
 * @param ?String
 */
function validateTruthyString(value) {
  validateString(value)
  if (!value) {
    throw new TypeError('expected a non-empty string, got: ' + value)
  }
}

/********************************** Export ***********************************/

module.exports = Statil
